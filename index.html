<html>
<head>
<style>td { white-space:pre }</style>
</head>
<body>
	<p>Very stupid early version, don't take any result seriously.</p>
	<p>For now it's hardcoded for meta build, so it won't add upgrades to priest, only dmg/chd for healer etc. I'll add more manual config options later.</p>
    <table>
        <tbody>
		<tr><td><label for="floor">Dungeon to beat: </label></td><td><input name="floor" value="300" id="floor" type="number"/></td></tr>
		<tr><td><label for="simulations">Builds to try: </label></td><td><input name="simulations" value="25000" id="simulations" type="number"/></td></tr>
		<tr><td><label for="wins">Win at least </label><input name="wins" value="5" style="width: 50px" id="wins" type="number"/><label for="wins"> in</label></td><td><input name="tries" value="500" id="tries" type="number"/></td></tr>
		<tr><td><label for="maxupgrade">Max upgrades per stat: </label></td><td><input name="maxupgrade" value="200" id="maxupgrade" type="number"/></td></tr>
		<tr><td colspan="2">Fighter 1-3 is front and 4-6 is back</td></tr>
		<tr><td><label for="fighter1">Fighter 1: </label></td><td><select name="fighter1" value="500" id="fighter1"/></td></tr>
		<tr><td><label for="fighter2">Fighter 2: </label></td><td><select name="fighter2" value="500" id="fighter2"/></td></tr>
		<tr><td><label for="fighter3">Fighter 3: </label></td><td><select name="fighter3" value="500" id="fighter3"/></td></tr>
		<tr><td><label for="fighter4">Fighter 4: </label></td><td><select name="fighter4" value="500" id="fighter4"/></td></tr>
		<tr><td><label for="fighter5">Fighter 5: </label></td><td><select name="fighter5" value="500" id="fighter5"/></td></tr>
		<tr><td><label for="fighter6">Fighter 6: </label></td><td><select name="fighter6" value="500" id="fighter6"/></td></tr>
        </tbody>
    </table>
<button onclick="startSim()">Simulate</button><div id="progress"></div>

<table id="simulationResult">
<thead>
<tr><th>Cost per relic</th><th>Total Cost</th><th>Fighter 1</th><th>Fighter 2</th><th>Fighter 3</th><th>Fighter 4</th><th>Fighter 5</th><th>Fighter 6</th></tr>
</thead>
<tbody>
</tbody>
</table>


<script>
const FULLHP = "fullhealth";
const HP = "health";
const DEF = "defense";
const DMG = "damage";
const CHD = "critdamage";
const HIT = "hit";
const DODGE = "dodge";
const TYPE = "type";
const FIGHTER = "fighter";
const MOB = "monster";
const CLASS = "class";
const NONE = "none";
const ASSASSIN = "assassin";
const BRAWLER = "brawler";
const CAVALRY = "cavalry";
const HEALER = "healer";
const HUNTER = "hunter";
const KNIGHT = "knight";
const MAGE = "mage";
const PRIEST = "priest";
const TANK = "tank";
const WARRIOR = "warrior";
const INDEX = "index";
const STUNNED = "stunned";
const DMGREDUCT = "dmgreduction";
const ANY = "any";

var maxUpgrade = 250;
var simulations = 100000;
var resultTable = null;
var progress = null;
var tries = 500;
var requiredWins = 5;

var classes = {"None": NONE, "Any": ANY, "Assassin": ASSASSIN, "Brawler": BRAWLER, "Cavalry": CAVALRY, "Healer": HEALER, "Hunter": HUNTER, "Knight": KNIGHT, "Mage": MAGE, "Priest": PRIEST, "Tank": TANK, "Warrior": WARRIOR};

(function() {
	for (var i = 1; i <= 6; i++) {
		var select = document.getElementById(FIGHTER + i);
		for (var key in classes) {
			select.options[select.options.length] = new Option(key, classes[key]);
		}
	}
	resultTable = document.getElementById("simulationResult");
	progress = document.getElementById("progress");
})();

function startSim() {
	tries = parseInt(document.getElementById("tries").value);
	requiredWins = parseInt(document.getElementById("wins").value);
	var level = parseInt(document.getElementById("floor").value);
	maxUpgrade = parseInt(document.getElementById("maxupgrade").value);
	simulations = parseInt(document.getElementById("simulations").value);
	var cheapestCost = -1;
	var relics = calculateRelics(level);
	var mobs = getMobs(level);
	doSimulation(1, mobs, relics, cheapestCost);
}

function doSimulation(simulation, mobs, relics, cheapestCost) {
	var fighters = initFighters();
	upgradeFighters(fighters, mobs[0]);
	var cost = calculateCost(fighters);
	applyUnique(fighters);
	var currentWins = 0;
	for (var currentTry = 1; currentTry <= tries; currentTry++) {
		var result = simulateCombat(fighters, mobs);
		if (result == FIGHTER) {
			currentWins++;
			if (currentWins >= requiredWins && (cheapestCost == -1 || cost < cheapestCost)) {
				cheapestCost = cost;
				var tbody = document.createElement("tbody");
				var row = tbody.insertRow();
				addColumn(row, 0, (cost/relics).toFixed(2));
				addColumn(row, 1, cost.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ","));
				addColumn(row, 2, fighterToString(fighters, 0));
				addColumn(row, 3, fighterToString(fighters, 1));
				addColumn(row, 4, fighterToString(fighters, 2));
				addColumn(row, 5, fighterToString(fighters, 3));
				addColumn(row, 6, fighterToString(fighters, 4));
				addColumn(row, 7, fighterToString(fighters, 5));
				var currentBody = resultTable.tBodies[0];
				resultTable.replaceChild(tbody, currentBody);
				break;
			}
		}
	}
	if (simulation >= simulations) {
		progress.innerHTML = "Finished!";
	} else if (simulation % 2500 == 0) {
		progress.innerHTML = simulation + "/" + simulations;
		setTimeout(function() { doSimulation(simulation+1, mobs, relics, cheapestCost); }, 0);
	} else {
		doSimulation(simulation+1, mobs, relics, cheapestCost);
	}
}

function fighterToString(fighters, index) {
	if (fighters.length > index) {
		var fighter = fighters[index];
		var result = fighter[CLASS] + "\n";
		result += "Health: " + fighter[FULLHP] + "\n";
		result += "Defense: " + fighter[DEF] + "\n";
		result += "Damage: " + fighter[DMG] + "\n";
		result += "Crit dmg: " + fighter[CHD] + "\n";
		result += "Hit: " + fighter[HIT] + "\n";
		result += "Dodge: " + fighter[DODGE];
		return result;
	}
	return "";
}

function addColumn(row, index, content) {	
	var relicCell = row.insertCell(index);
	relicCell.appendChild(document.createTextNode(content));
}

function calculateRelics(level) {
	return level*(level+1)*250-Math.max(0,level-200)*Math.max(0,level-199)*125;
}

function upgradeFighters(fighters, strongestMob) {
	fighters.forEach(function(fighter) {
		switch(fighter[CLASS]) {
			case HEALER:
				var dmgUpgrades = getRandomUpgrade();
				fighter[DMG] += 25 * dmgUpgrades;
				fighter[CHD] += 0.25 * Math.round(dmgUpgrades / 25);
				break;
			case PRIEST:
				break;
			case KNIGHT:
				fighter[DEF] += 10 * getRandomUpgrade();
				var mobDamage = strongestMob[DMG] * (1 + strongestMob[CHD] / 100) - fighter[DEF];
				var minHP = Math.floor((mobDamage - 500) / 225);
				if (minHP < 0) {
					minHP = 0;
				}
				fighter[FULLHP] += 100 * getRandomUpgrade(minHP);
				fighter[DODGE] += 50 * getRandomUpgrade();
				break;
			case TANK:
				fighter[DEF] += 10 * getRandomUpgrade();
				var mobDamage = strongestMob[DMG] * (1 + strongestMob[CHD] / 100) - fighter[DEF];
				var minHP = Math.floor((mobDamage - 500) / 225);
				if (minHP < 0) {
					minHP = 0;
				}
				fighter[FULLHP] += 100 * getRandomUpgrade(minHP);
				fighter[DODGE] += 50 * getRandomUpgrade();
				var dmg = 56.25
				var minDmg = Math.floor((strongestMob[DEF] - 100) / dmg);
				if (minDmg < 0) {
					minDmg = 0;
				}
				var dmgUpgrades = getRandomUpgrade(minDmg);
				fighter[DMG] += 25 * dmgUpgrades;
				fighter[CHD] += 0.25 * Math.round(dmgUpgrades / 25);
				fighter[HIT] += 50 * getRandomUpgrade();
				break;
			default:
				var dmg = 56.25;
				if (fighter[CLASS] == MAGE) dmg *= 0.4;
				if (fighter[CLASS] == HUNTER) dmg *= 0.6;
				var minDmg = Math.floor((strongestMob[DEF] - 100) / dmg);
				if (minDmg < 0) {
					minDmg = 0;
				}
				var dmgUpgrades = getRandomUpgrade(minDmg);
				fighter[DMG] += 25 * dmgUpgrades;
				fighter[CHD] += 0.25 * Math.round(dmgUpgrades / 25);
				fighter[HIT] += 50 * getRandomUpgrade();
				break;
		}
	});
}

function getRandomUpgrade(minUpgrade) {
	minUpgrade = minUpgrade || 0;
	return Math.floor(Math.random() * (maxUpgrade - minUpgrade + 1)) + minUpgrade;
}

function applyUnique(fighters) {
	var classes = [];
	fighters.forEach(function(fighter) { 
		classes.push(fighter[CLASS]);
	});
	var uniqueMultiplier = 1 + (new Set(classes)).size * 0.25;
	fighters.forEach(function(fighter) {
		fighter[FULLHP] *= uniqueMultiplier;
		fighter[DEF] *= uniqueMultiplier;
		fighter[DMG] *= uniqueMultiplier;
		fighter[CHD] *= uniqueMultiplier;
		fighter[HIT] *= uniqueMultiplier;
		fighter[DODGE] *= uniqueMultiplier;
	});
}

function initFighters() {
	var fighters = [];
	for (var i = 1; i <= 6; i++) {
		var fighterClass = document.getElementById(FIGHTER + i).value;
		if (fighterClass != NONE) {
			if (fighterClass == ANY) {
				var keys = Object.keys(classes);
				fighterClass = classes[keys[Math.floor((keys.length - 2) * Math.random() + 2)]];
			}
			var fighter = [];
			fighter[INDEX] = i-1;
			fighter[TYPE] = FIGHTER;
			fighter[FULLHP] = 500;
			fighter[DEF] = 25;
			fighter[DMG] = 100;
			fighter[CHD] = 0;
			fighter[HIT] = 50;
			fighter[DODGE] = 50;
			fighter[CLASS] = fighterClass;
			fighter[STUNNED] = 0;
			fighter[DMGREDUCT] = 0;
			fighters.push(fighter);
		}
	}
	return fighters;
}

function calculateCost(fighters) {
	var cost = 0;
	var fighterCost = 1000;
	fighters.forEach(function(fighter) { 
	var test = fighter[CLASS];
		fighterCost *= 10;
		cost += fighterCost;
		cost += getCost(500, fighter[FULLHP], 100);
		cost += getCost(25, fighter[DEF], 10);
		cost += getCost(100, fighter[DMG], 25);
		cost += getCost(0, fighter[CHD], 0.25);
		cost += getCost(50, fighter[HIT], 50);
		cost += getCost(50, fighter[DODGE], 50);
	});
	return cost -= 10000;
}

function getCost(startValue, currentValue, increment) {
	var paidValue = currentValue - startValue;
	if (paidValue == 0) return 0;
	return paidValue * (paidValue/increment+1) * (5000/increment);
}

function resetHealth(fighters) {
	fighters.forEach(function(fighter) {
		fighter[HP] = fighter[FULLHP];
	});
}

function simulateCombat(fighters, mobs) {
	resetHealth(fighters);
	resetHealth(mobs);
	var battleOrder = mobs.concat(fighters);
	battleOrder.sort(function(a, b) { return b[HIT] - a[HIT]});
	var winner = null;
	for (var round = 1; round <= 150; round++) {
		battleOrder.some(function(battlerTurn) {
			var currentBattler = null;
			if (battlerTurn[TYPE] == MOB) {
				currentBattler = mobs[battlerTurn[INDEX]];
			} else {
				currentBattler = fighters[battlerTurn[INDEX]];
			}
			if (currentBattler[HP] <= 0) {
				if (currentBattler[CLASS] == PRIEST && Math.random() <= 0.1) {
					currentBattler[HP] = currentBattler[FULLHP] / 2;
				}
			} else if (currentBattler[CLASS] != KNIGHT && currentBattler[STUNNED] == 0) {
				for (var attacks = 1; attacks <= getAttacks(currentBattler); attacks++) {
					var targets = getTargets(currentBattler, fighters, mobs);
					if (currentBattler[CLASS] == HEALER) {
						targets[0][HP] += currentBattler[DMG] * getCritMultiplier(currentBattler) * 0.75;
						if (targets[0][HP] > targets[0][FULLHP]) targets[0][HP] = targets[0][FULLHP];
						return false;
					}
					if (targets.length == 0) {
						if (currentBattler[TYPE] == FIGHTER) {
							winner = FIGHTER;
						} else {
							winner = MOB;
						}
						return true;
					}
					targets.forEach(function(currentTarget) {
						if (currentTarget[CLASS] != KNIGHT || Math.random() <= 0.6) {
							var hitAmount = getHit(currentBattler);
							var hitchance = hitAmount / (hitAmount + currentTarget[DODGE]);
							if (Math.random() <= hitchance) {
								var damage = currentBattler[DMG] * getCritMultiplier(currentBattler) * getDamageReduction(currentTarget, round);
								if (currentBattler[CLASS] == MAGE) damage *= 0.4;
								if (currentBattler[CLASS] == HUNTER) damage *= 0.6;
								damage -= currentTarget[DEF];
								if (damage < 0) damage = 0;
								currentTarget[HP] -= damage;
								if (currentBattler[CLASS] == WARRIOR && Math.random() <= 0.1) {
									currentTarget[STUNNED] = 2;
								}
							}
						}
					});
					if (currentBattler[TYPE] == MOB && getFirstAlive(fighters).length == 0) {
						winner = MOB;
						return true;
					} else if (currentBattler[TYPE] == FIGHTER && getFirstAlive(mobs).length == 0) {
						winner = FIGHTER;
						return true;
					}
				}
			}
			if (currentBattler[STUNNED] > 0) currentBattler[STUNNED]--;
			return false;
		});
		if (winner != null) return winner;
	}
	return MOB;
}

function getHit(currentBattler) {
	if (currentBattler[CLASS] == CAVALRY) return currentBattler[HIT] * 2;
	return currentBattler[HIT];
}

function getAttacks(currentBattler) {
	if (currentBattler[CLASS] == BRAWLER && Math.random() <= 0.15) return 2;
	return 1;
}

function getDamageReduction(target, round) {
	if (target[CLASS] != TANK) return 1;
	if (target[DMGREDUCT] <= round - 3 && Math.random() <= 0.15) {
		target[DMGREDUCT] = round;
	}
	if (target[DMGREDUCT] != 0 && target[DMGREDUCT] > round - 3) {
		return 0.5;
	}
	return 1;
}

function getCritMultiplier(currentBattler) {
	var critDmg = 1;
	if (Math.random() <= 0.1) {
		critDmg += (currentBattler[CHD]/100);
	}
	return critDmg;
}

function getTargets(currentBattler, fighters, mobs) {
	if (currentBattler[TYPE] == MOB) return getFirstAlive(fighters);
	switch (currentBattler[CLASS]) {
		case ASSASSIN:
			return getBackColumnTarget(mobs);
		case HUNTER:
			var firstTarget = getFirstAlivePosition(mobs);
			if (firstTarget == -1) return [];
			if (firstTarget < 3 && mobs.length > firstTarget + 3 && mobs[firstTarget + 3][HP] > 0) {
				return [mobs[firstTarget], mobs[firstTarget + 3]];
			}
			return [mobs[firstTarget]];
		case MAGE:
			var firstTarget = getFirstAlivePosition(mobs);
			if (firstTarget == -1) return [];
			var targets = [mobs[firstTarget]];
			var size = mobs.length;
			var limit = firstTarget < 3 ? 2 : 5;
			for (var i = firstTarget + 1; i <= limit; i++) {
				if (size > i && mobs[i][HP] > 0) {
					targets.push(mobs[i]);
				}
			}
			return targets;
		case HEALER:
			return getHealTarget(fighters);
		default:
			return getFirstAlive(mobs);
	}
}

function getFirstAlive(battlers) {
	var target = null;
	battlers.some(function(currentBattler) {
		if (currentBattler[HP] > 0) {
			target = currentBattler;
			return true;
		}
		return false;
	});
	if (target == null) return [];
	return [target];
}

function getFirstAlivePosition(mobs) {
	var size = mobs.length;
	for (var i = 0; i < 6; i++) {
		if (size > i && mobs[i][HP] > 0) return i;
	}
	return -1;
}

function getBackColumnTarget(mobs) {
	var size = mobs.length;
	for (var i = 3; i < 6; i++) {
		if (size > i && mobs[i][HP] > 0) return [mobs[i]];
	}
	return getFirstAlive(mobs);
}

function getHealTarget(fighters) {
	var target = null;
	var healthDiff = -1;
	fighters.forEach(function(currentBattler) {
		if (currentBattler[HP] > 0 && currentBattler[FULLHP] - currentBattler[HP] > healthDiff) {
			target = currentBattler;
			healthDiff = currentBattler[FULLHP] - currentBattler[HP];
		}
	});
	return [target];
}

function getMobs(level) {
    var mobs = [];
	for (var i = 0; i <= Math.floor(level/50); i++) {
		var mobLevel = level - 25 * i;
		var mob = [];
		mob[INDEX] = i;
		mob[TYPE] = MOB;
		mob[FULLHP] = mobLevel * 400 + 100;
		mob[DEF] = mobLevel * 10 + 20;
		mob[DMG] = mobLevel * 40 + 60;
		mob[CHD] = mobLevel * 0.25;
		mob[HIT] = mobLevel * 30 + 50;
		mob[DODGE] = mobLevel * 30 + 50;
		mob[CLASS] = NONE;
		mob[STUNNED] = 0;
		mob[DMGREDUCT] = 0;
		mobs.push(mob);
	}
	return mobs;
}
</script>
</body>
</html>
